---
alwaysApply: true
---

## Project Overview
pymai is a tiny-yet-powerful Python framework for composable AI agents and durable workflows, inspired by PyTorch's modular design. The goal is to provide a unified Module abstraction that works seamlessly with both sync and async code, with built-in observability and context propagation.

## Core Architecture Principles

### 1. Single Module Abstraction (DP-1)
- All components inherit from `mai.layers.Module`
- One class to learn, unified interface
- Subclass and implement `forward()` method

### 2. Sync/Async Auto-Detection (DP-2)
- Runtime automatically detects if `forward()` is sync or async
- Sync functions run in thread pool to keep event loop responsive
- No manual async/await boilerplate required

### 3. Type-Safe I/O (DP-3)
- Use Pydantic models for data validation and serialization
- Zero-copy data flow between modules via strongly-typed Payload envelopes
- Strong typing for all public APIs with runtime validation
- **"Know your types; Fail if unsure"** - explicit type definitions required

### 4. Invisible Context (DP-4)
- Context propagation via `contextvars`
- Deadlines, tracing, auth without polluting signatures
- Access via `get_current_context()` when needed

### 5. Observability First (DP-5)
- Rich tracing with OpenTelemetry
- Built-in metrics and error tracking
- Production-ready monitoring out of the box

### 6. Configurable Modules (DP-6)
- Use `.with_(**cfg)` for static configuration
- Per-call overrides via kwargs
- Configuration flows through context

### 7. Micro-Kernel Core (DP-7)
- Core framework â‰¤ 2kLOC
- Heavy lifting in backend implementations
- Pluggable execution engines

### 8. Durable Workflows (DP-8)
- Replay-able, resumable, idempotent steps
- Future: Temporal-style distributed execution
- Checkpoint and recovery capabilities

## Roadmap Alignment
- Keep changes aligned with M-0 through M-4 milestones
- Consider distributed workflow requirements
- Plan for XCP transport integration
- Design for quantized model support

## Backward Compatibility
- Maintain API stability within major versions
- Use deprecation warnings for breaking changes
- Provide migration guides for major updates

## AI Assistant Guidelines

When helping with this codebase:

1. **Follow PyTorch inspiration**: Suggest modular, composable designs
2. **Emphasize strong typing**: Always define explicit Pydantic models for data transfer
3. **Enforce "Know your types; Fail if unsure"**: Reject `Any` types in public APIs
4. **Consider async/sync**: Always think about both execution modes
5. **Include tests**: Always suggest or provide test code including type validation
6. **Update documentation**: Keep docs in sync with code changes
7. **Respect architecture**: Don't violate the 8 design principles
8. **Think production**: Consider observability, error handling, performance
9. **Maintain consistency**: Follow established patterns and conventions

Remember: The goal is to make AI agent development as simple and composable as PyTorch made deep learning.
